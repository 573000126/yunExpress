<#@ template language="C#" debug="false" hostspecific="true"#>
<#@ include file="EF.Utility.CS.ttinclude"#><#@
 output extension=".cs"#><#

var loader = new MetadataLoader(this);
var region = new CodeRegion(this);
var inputFile = @"LMS_DBContext.edmx";
var ItemCollection = loader.CreateEdmItemCollection(inputFile);

Code = new CodeGenerationTools(this);
EFTools = new MetadataTools(this);
ObjectNamespace = Code.VsNamespaceSuggestion();
ModelNamespace = loader.GetModelNamespace(inputFile);

EntityContainer container = ItemCollection.GetItems<EntityContainer>().FirstOrDefault();
if (container == null)
{
    return string.Empty;
}
#>
//------------------------------------------------------------------------------
// <auto-generated>
//    This code was generated from a template.
//
//    Manual changes to this file may cause unexpected behavior in your application.
//    Manual changes to this file will be overwritten if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#pragma warning disable 1573
<#

if (!String.IsNullOrEmpty(ObjectNamespace))
{
#>
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.ModelConfiguration.Conventions;
using System.Data.Entity.Validation;
using System.Linq;
using System.Data.Entity.Core.Objects;

using LMS.Data.Entity;
using LighTake.Infrastructure.Seedwork;
using LighTake.Infrastructure.Seedwork.EF;

namespace <#=Code.EscapeNamespace(ObjectNamespace)#>
{
<#
    PushIndent(CodeRegion.GetIndent(1));
}

#>

<#=Accessibility.ForType(container)#> partial class <#=Code.Escape(container)#> : DbContext, IQueryableUnitOfWork
{
    static <#=Code.Escape(container)#>()
	{ 
		Database.SetInitializer<<#=Code.Escape(container)#>>(null);
	}
	
	public <#=Code.Escape(container)#>() : base("name=<#=container.Name#>")
    {
		//this.Configuration.LazyLoadingEnabled = true;
		//this.Configuration.ProxyCreationEnabled = false;
		this.Configuration.UseDatabaseNullSemantics = true;
		if (System.Configuration.ConfigurationManager.AppSettings["LogSql"] != null &&
    	        System.Configuration.ConfigurationManager.AppSettings["LogSql"] == "1")
    	    {
				this.Database.Log = t => LighTake.Infrastructure.Common.Logging.Log.Debug(t);
			}
    }
	
	public <#=Code.Escape(container)#>(string nameOrConnectionString) : base(nameOrConnectionString)
	{	
	}

	public <#=Code.Escape(container)#>(string nameOrConnectionString, DbCompiledModel model) : base(nameOrConnectionString, model)
	{
	}

	public <#=Code.Escape(container)#>(DbConnection existingConnection, bool contextOwnsConnection) : base(existingConnection, contextOwnsConnection)
	{
	}

	public <#=Code.Escape(container)#>(DbConnection existingConnection, DbCompiledModel model, bool contextOwnsConnection) : base(existingConnection, model, contextOwnsConnection)
	{
	}
    protected override void OnModelCreating(DbModelBuilder modelBuilder)
    {
		modelBuilder.Conventions.Remove<OneToManyCascadeDeleteConvention>();
<# 
    foreach (EntityType entitySet in ItemCollection.GetItems<EntityType>().OrderBy(e => e.Name))
    {
#>
		modelBuilder.Configurations.Add(new <#=Code.Escape(entitySet.Name)#>_Mapping());
<#
    }
#>
    }

	#region IQueryableUnitOfWork Members
        
            public DbSet<TEntity> CreateSet<TEntity>()
                where TEntity : class
            {
                return base.Set<TEntity>();
            }
        
            public void Attach<TEntity>(TEntity item) 
                where TEntity : class
            {
                //attach and set as unchanged
                base.Entry<TEntity>(item).State = EntityState.Unchanged;
            }
        
            public void SetModified<TEntity>(TEntity item) 
                where TEntity : class
            {
                //this operation also attach item in object state manager
                base.Entry<TEntity>(item).State = EntityState.Modified;
            }
            public void ApplyCurrentValues<TEntity>(TEntity original, TEntity current)
                where TEntity : class
            {
                //if it is not attached, attach original and set current values
                base.Entry<TEntity>(original).CurrentValues.SetValues(current);
            }
        
            public int Commit()
            {
        		try
        		{
        			return base.SaveChanges();
        		}
        		catch (DbEntityValidationException dbEx)
                {
        
                    var msg = string.Empty;
        
                    foreach (var validationErrors in dbEx.EntityValidationErrors)
                        foreach (var validationError in validationErrors.ValidationErrors)
                            msg += string.Format("Property: {0} Error: {1}", validationError.PropertyName, validationError.ErrorMessage) + Environment.NewLine;
        
                    var fail = new Exception(msg, dbEx);
                    //Debug.WriteLine(fail.Message, fail);
                    throw fail;
                }
            }

        private DbTransaction _transaction;

        public bool IsInTransaction { get { return _transaction != null; } }
        public void BeginTransaction()
        {
            BeginTransaction(IsolationLevel.ReadCommitted);
        }

        public void BeginTransaction(IsolationLevel isolationLevel)
        {
            if (_transaction != null)
            {
                throw new ApplicationException("Cannot begin a new transaction while an existing transaction is still running. " +
                                                "Please commit or rollback the existing transaction before starting a new one.");
            }
            OpenConnection();
            _transaction = base.Database.Connection.BeginTransaction(isolationLevel);
        }

        private void OpenConnection()
        {
            if (base.Database.Connection.State != ConnectionState.Open)
            {
                base.Database.Connection.Open();
            }
        }
        public void RollbackTransaction()
        {
            _transaction.Rollback();
        }

        public void CommitTransaction()
        {
            if (_transaction == null)
            {
                throw new ApplicationException("Cannot roll back a transaction while there is no transaction running.");
            }

            try
            {
                base.SaveChanges();
                _transaction.Commit();
            }
            catch
            {
                _transaction.Rollback();
                throw;
            }
            finally
            {
                ReleaseCurrentTransaction();
            }
        }

        /// <summary>
        /// Releases the current transaction
        /// </summary>
        private void ReleaseCurrentTransaction()
        {
            if (_transaction != null)
            {
                _transaction.Dispose();
                _transaction = null;
            }
        }

        public void CommitAndRefreshChanges()
            {
                bool saveFailed = false;
        
                do
                {
                    try
                    {
                        base.SaveChanges();
        
                        saveFailed = false;
        
                    }
                    catch (DbUpdateConcurrencyException ex)
                    {
                        saveFailed = true;
        
                        ex.Entries.ToList()
                                    .ForEach(entry =>entry.OriginalValues.SetValues(entry.GetDatabaseValues()));
        
                    }
                } while (saveFailed);
        
            }
        
        public void RollbackChanges()
            {
                // set all entities in change tracker 
                // as 'unchanged state'
                base.ChangeTracker.Entries()
                                    .ToList()
                                    .ForEach(entry => entry.State = EntityState.Detached);
            }
    

    /// <summary>
    /// Create database script
    /// </summary>
    /// <returns>SQL to generate database</returns>
    public string CreateDatabaseScript()
    {
        return ((IObjectContextAdapter)this).ObjectContext.CreateDatabaseScript();
    }

    /// <summary>
    /// Get DbSet
    /// </summary>
    /// <typeparam name="TEntity">Entity type</typeparam>
    /// <returns>DbSet</returns>
    public new IDbSet<TEntity> Set<TEntity>() where TEntity : LighTake.Infrastructure.Seedwork.Entity
    {
        return base.Set<TEntity>();
    }

    public IEnumerable<TEntity> ExecuteQuery<TEntity>(string sqlQuery, params object[] parameters)
    {
        return base.Database.SqlQuery<TEntity>(sqlQuery, parameters);
    }

    public int ExecuteCommand(string sqlCommand, params object[] parameters)
    {
        return base.Database.ExecuteSqlCommand(sqlCommand, parameters);
    }
        
    public IList<TEntity> ExecuteStoredProcedureList<TEntity>(string commandText, params object[] parameters) 
    {
        //HACK: Entity Framework Code First doesn't support doesn't support output parameters
        //That's why we have to manually create command and execute it.
        //just wait until EF Code First starts support them
        //
        //More info: http://weblogs.asp.net/dwahlin/archive/2011/09/23/using-entity-framework-code-first-with-stored-procedures-that-have-output-parameters.aspx
    
        bool hasOutputParameters = false;
        if (parameters != null)
        {
            foreach (var p in parameters)
            {
                var outputP = p as DbParameter;
                if (outputP == null)
                    continue;
    
    			outputP.Value = outputP.Value??DBNull.Value;
    
                if (outputP.Direction == ParameterDirection.InputOutput ||
                    outputP.Direction == ParameterDirection.Output)
                    hasOutputParameters = true;
            }
        }
    
    
    
        var context = ((IObjectContextAdapter)(this)).ObjectContext;
        if (!hasOutputParameters)
        {
            //no output parameters
            var result = this.Database.SqlQuery<TEntity>(commandText, parameters).ToList();
            //for (int i = 0; i < result.Count; i++)
            //    result[i] = AttachEntityToContext(result[i]);
                            
            return result;
                    
            //var result = context.ExecuteStoreQuery<TEntity>(commandText, parameters).ToList();
            //foreach (var entity in result)
            //    Set<TEntity>().Attach(entity);
            //return result;
        }
        else
        {
    
            //var connection = context.Connection;
            var connection = this.Database.Connection;
            //Don't close the connection after command execution
    
    
            //open the connection for use
            if (connection.State == ConnectionState.Closed)
                connection.Open();
            //create a command object
            using (var cmd = connection.CreateCommand())
            {
                //command to execute
                cmd.CommandText = commandText;
                cmd.CommandType = CommandType.StoredProcedure;
    
                // move parameters to command object
                if (parameters != null)
                    foreach (var p in parameters)
                        cmd.Parameters.Add(p);
    
                //database call
                var reader = cmd.ExecuteReader();
                //return reader.DataReaderToObjectList<TEntity>();
                var result = context.Translate<TEntity>(reader).ToList();
                //for (int i = 0; i < result.Count; i++)
                //    result[i] = AttachEntityToContext(result[i]);
                //close up the reader, we're done saving results
                reader.Close();
                return result;
            }
    
        }
    }

    public bool ExecuteStoredProcedureList(string commandText, params object[] parameters)
    {
        //HACK: Entity Framework Code First doesn't support doesn't support output parameters
        //That's why we have to manually create command and execute it.
        //just wait until EF Code First starts support them
        //
        //More info: http://weblogs.asp.net/dwahlin/archive/2011/09/23/using-entity-framework-code-first-with-stored-procedures-that-have-output-parameters.aspx
    
        bool bResult = false;
        if (parameters != null)
        {
            foreach (var p in parameters)
            {
                var outputP = p as DbParameter;
                if (outputP == null)
                    continue;
                outputP.Value = outputP.Value ?? DBNull.Value;
            }
        }
        //var connection = context.Connection;
        var connection = this.Database.Connection;
        //Don't close the connection after command execution
        //open the connection for use
        if (connection.State == ConnectionState.Closed)
            connection.Open();
        //create a command object
        using (var cmd = connection.CreateCommand())
        {
            //command to execute
            cmd.CommandText = commandText;
            cmd.CommandType = CommandType.StoredProcedure;
    
            // move parameters to command object
            if (parameters != null)
                foreach (var p in parameters)
                    cmd.Parameters.Add(p);
    
            //database call
            DbDataReader reader = null;
            try
            {
                reader = cmd.ExecuteReader();
                bResult= true;
            }
            finally
            {
                if (reader != null)
                    reader.Close();
            }
        }
        return bResult;
    }

    /// <summary>
    /// Creates a raw SQL query that will return elements of the given generic type.  The type can be any type that has properties that match the names of the columns returned from the query, or can be a simple primitive type. The type does not have to be an entity type. The results of this query are never tracked by the context even if the type of object returned is an entity type.
    /// </summary>
    /// <typeparam name="TElement">The type of object returned by the query.</typeparam>
    /// <param name="sql">The SQL query string.</param>
    /// <param name="parameters">The parameters to apply to the SQL query string.</param>
    /// <returns>Result</returns>
    public IEnumerable<TElement> SqlQuery<TElement>(string sql, params object[] parameters)
    {
        return this.Database.SqlQuery<TElement>(sql, parameters);
    }
    
    /// <summary>
    /// Executes the given DDL/DML command against the database.
    /// </summary>
    /// <param name="sql">The command string</param>
    /// <param name="doNotEnsureTransaction">false - the transaction creation is not ensured; true - the transaction creation is ensured.</param>
    /// <param name="timeout">Timeout value, in seconds. A null value indicates that the default value of the underlying provider will be used</param>
    /// <param name="parameters">The parameters to apply to the command string.</param>
    /// <returns>The result returned by the database after executing the command.</returns>
    public int ExecuteSqlCommand(string sql, bool doNotEnsureTransaction = false, int? timeout = null, params object[] parameters)
    {
        int? previousTimeout = null;
        if (timeout.HasValue)
        {
            //store previous timeout
            previousTimeout = ((IObjectContextAdapter) this).ObjectContext.CommandTimeout;
            ((IObjectContextAdapter) this).ObjectContext.CommandTimeout = timeout;
        }

        var transactionalBehavior = doNotEnsureTransaction
            ? TransactionalBehavior.DoNotEnsureTransaction
            : TransactionalBehavior.EnsureTransaction;
        var result = this.Database.ExecuteSqlCommand(transactionalBehavior, sql, parameters);

        if (timeout.HasValue)
        {
            //Set previous timeout back
            ((IObjectContextAdapter) this).ObjectContext.CommandTimeout = previousTimeout;
        }

        //return result
        return result;
    }

    #endregion

	#region IDbSet Members

<#
		
    foreach (var entitySet in container.BaseEntitySets.OfType<EntitySet>())
    {
#>
    <#=Accessibility.ForReadOnlyProperty(entitySet)#> DbSet<<#=Code.Escape(entitySet.ElementType)#>> <#=Code.Escape(entitySet)#> { get; set; }
<#
    }
#>

	#endregion
<#
    
		
       
    foreach (var edmFunction in container.FunctionImports)
    {
        WriteFunctionImport(edmFunction, false);
    }
#>
}
<#

if (!String.IsNullOrEmpty(ObjectNamespace))
{
    PopIndent();
#>
}
<#
}
#>
<#+
string ModelNamespace { get; set; }
string ObjectNamespace { get; set; }
CodeGenerationTools Code { get; set; }
MetadataTools EFTools { get; set; }

void WriteLazyLoadingEnabled(EntityContainer container)
{
   string lazyLoadingAttributeValue = null;
   var lazyLoadingAttributeName = MetadataConstants.EDM_ANNOTATION_09_02 + ":LazyLoadingEnabled";
   if(MetadataTools.TryGetStringMetadataPropertySetting(container, lazyLoadingAttributeName, out lazyLoadingAttributeValue))
   {
       bool isLazyLoading;
       if(bool.TryParse(lazyLoadingAttributeValue, out isLazyLoading) && !isLazyLoading)
       {
#>
        this.Configuration.LazyLoadingEnabled = false;
<#+
       }
   }
}

void WriteFunctionImport(EdmFunction edmFunction, bool includeMergeOption)
{
    var parameters = FunctionImportParameter.Create(edmFunction.Parameters, Code, EFTools);
    var paramList = String.Join(", ", parameters.Select(p => p.FunctionParameterType + " " + p.FunctionParameterName).ToArray());
    var returnType = edmFunction.ReturnParameter == null ? null : EFTools.GetElementType(edmFunction.ReturnParameter.TypeUsage);
    var processedReturn = returnType == null ? "int" : "ObjectResult<" + MultiSchemaEscape(returnType) + ">";

    if (includeMergeOption)
    {
        paramList = Code.StringAfter(paramList, ", ") + "MergeOption mergeOption";
    }
#>

    <#=AccessibilityAndVirtual(Accessibility.ForMethod(edmFunction))#> <#=processedReturn#> <#=Code.Escape(edmFunction)#>(<#=paramList#>)
    {
<#+
        if(returnType != null && (returnType.EdmType.BuiltInTypeKind == BuiltInTypeKind.EntityType ||
                                  returnType.EdmType.BuiltInTypeKind == BuiltInTypeKind.ComplexType))
        {
#>
        ((IObjectContextAdapter)this).ObjectContext.MetadataWorkspace.LoadFromAssembly(typeof(<#=MultiSchemaEscape(returnType)#>).Assembly);

<#+
        }

        foreach (var parameter in parameters.Where(p => p.NeedsLocalVariable))
        {
            var isNotNull = parameter.IsNullableOfT ? parameter.FunctionParameterName + ".HasValue" : parameter.FunctionParameterName + " != null";
            var notNullInit = "new ObjectParameter(\"" + parameter.EsqlParameterName + "\", " + parameter.FunctionParameterName + ")";
            var nullInit = "new ObjectParameter(\"" + parameter.EsqlParameterName + "\", typeof(" + parameter.RawClrTypeName + "))";
#>
        var <#=parameter.LocalVariableName#> = <#=isNotNull#> ?
            <#=notNullInit#> :
            <#=nullInit#>;

<#+
        }

        var genericArg = returnType == null ? "" : "<" + MultiSchemaEscape(returnType) + ">";
        var callParams = Code.StringBefore(", ", String.Join(", ", parameters.Select(p => p.ExecuteParameterName).ToArray()));

        if (includeMergeOption)
        {
            callParams = ", mergeOption" + callParams;
        }
#>
        return ((IObjectContextAdapter)this).ObjectContext.ExecuteFunction<#=genericArg#>("<#=edmFunction.Name#>"<#=callParams#>);
    }
<#+
    if(!includeMergeOption && returnType != null && returnType.EdmType.BuiltInTypeKind == BuiltInTypeKind.EntityType)
    {
        WriteFunctionImport(edmFunction, true);
    }
}

string AccessibilityAndVirtual(string accessibility)
{
    return accessibility + (accessibility != "private" ? " virtual" : "");
}

string MultiSchemaEscape(TypeUsage usage)
{
    var type = usage.EdmType as StructuralType;
    return type != null && type.NamespaceName != ModelNamespace ?
        Code.CreateFullName(Code.EscapeNamespace(type.NamespaceName), Code.Escape(type)) :
        Code.Escape(usage);
}

#>